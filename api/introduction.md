---
title: Введение
description: Введение в API LUA
published: false
date: 2023-06-24T05:23:15.605Z
tags: 
editor: markdown
dateCreated: 2023-06-23T16:52:20.334Z
---

# Введение
Добро пожаловать в документацию Lua API для Scrap Mechanic!

В этой документации вы найдете подробную информацию, относящуюся к Lua-скриптам Scrap Mechanic. Для получения более общей информации о том, как работает скриптовый язык программирования Lua, вы можете ознакомиться с [официальной документацией Lua](https://www.lua.org/docs.html).

Scrap Mechanic использует Lua версии 5.1. Дополнительную информацию смотрите в [официальном руководстве](https://www.lua.org/manual/5.1/).

Документация также доступна в [автономном режиме](https://scrapmechanic.com/api/html.zip), в [формате json](https://scrapmechanic.com/api/json.zip) и [файле документации lua](https://scrapmechanic.com/api/lua.zip).

## Консоль
Рекомендуется запускать игру с параметром запуска "-dev" при написании скрипта для того, чтобы получить доступ к консоли отладки и включить функцию горячей перезагрузки скрипта. Используйте [`print`](TODO:global_names#print) для печати в консоли.

## Классы
Классы выступают в качестве точки входа из игры в ваш Lua скрипт. Для добавления скрипта в вашу интерактивную деталь, вам необходимо прописать его в 
```json
"scripted": {
		"filename": "$CONTENT_DATA/Scripts/MyShape.lua",
		"classname": "MyShape",
		"data": { "hello": "Hello world!" }
},
```
### Пример Lua-скрипта:
```lua
-- Создаём новый класс
MyShape = class()

-- Устанавливаем переменные ShapeClass
MyShape.maxParentCount = 1 -- Максимальное количество подключений к детали
MyShape.maxChildCount = 0 -- Максимальное количество подключений от детали
MyShape.connectionInput = sm.interactable.connectionType.none -- Тип соединения, который может быть подключен к детали
MyShape.connectionOutput = sm.interactable.connectionType.logic -- Тип соединения, который может быть подключен от детали
MyShape.colorNormal = sm.color.new( 0x777777ff ) -- Цвет "точки" в соединителе
MyShape.colorHighlight = sm.color.new( 0x888888ff ) -- Цвет "точки" в соединителе, когда на неё наводишься

-- Вызывается при создании скрипта (установке детали, вход в мир). Серверная часть
function MyShape:server_onCreate()
	print( self.data.hello )
end

-- Вызывается при создании скрипта (установке детали, вход в мир). Клиентская часть
function MyShape:client_onCreate()
	self.cl = { time = 0 }
end

-- Вызывается каждый тик. 1 секунда - 40 тиков
function MyShape:client_onFixedUpdate( timeStep )
	self.cl.time = self.cl.time + timeStep
end

-- Вызывается при нажатии интерактивной клавиши. По умолчанию E.
function MyShape:client_onInteract( character, state )
	if state then
		print( "E нажато" )
		self.network:sendToServer( "sv_n_toggle" )
	else
		print( "E отпущено" )
	end
	print( "Деталь зажата на протяжении", self.cl.time, "секунд" )
end

function MyShape:sv_n_toggle() 
	-- Переключает состояние вкл/выкл
	self.interactable.active = not self.interactable.active
end
```
## Статические функции
Статические функции могут быть вызваны из Lua для выполнения определенных действий в игре, таких как создание детали с помощью [`sm.shape.createPart`](TODO:link_to_func). Функция `createPart` вернет объект `userdata` типа [`Shape`](TODO:link_to_type), который можно использовать для ссылки на деталь. Эта ссылка действительна до тех пор, пока данная часть все еще существует в игре.
## Пользовательские данные
Userdata - это часть Lua, для определения пользовательских объектов. Scrap Mechanic использует пользовательские данные для добавления игровых объектов, таких как ['Shape'](TODO:link_to_type) (деталь), а также служебных объектов, таких как ['Vec3'](TODO:link_to_type). Они похожи на [экземпляры](https://ru.wikipedia.org/wiki/Объект_(программирование)) в [объектно-ориентированном программировании](https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование). Объекты userdata имеют набор значений-членов и функций.

Вот пример, функция [getColor](TODO:link_to_func), которая возвращает userdata типа [Color](TODO:link_to_type):
```lua
local color = myShape:getColor() -- получить цвет детали
myOtherShape:setColor( color ) -- Копируем цвет предыдущей детали на другую
```

Userdata также могут иметь переменные. Это делает точно то же самое, что и описанное выше:


```lua
local color = myShape.color -- получить цвет детали
myOtherShape.color = color) -- Копируем цвет предыдущей детали на другую
```
Другой способ получить объект [Color](TODO:link_to_type) - это вызвать [sm.color.new](TODO:link_to_func). Вот пример, в котором цвет детали будет установлен на красный:
```lua
local color = sm.color.new( 1.0, 0.0, 0.0 ) -- создаём userdata типа Color
myShape.color = color -- Устанавливаем цвет детали на красный, способом, описанным выше.
```
## Песочницы
Когда Lua коды выполняются в игре, они выполняются в неких "песочницах". Песочница гарантирует, что функции, не разрешённые к выполнению в ней, не будут выполнены. 
Одна из причин существования песочницы заключается в обеспечении соблюдения структуры сервер / клиент, это помогает убедиться, что скрипты работают при многопользовательской игре.
Песочница блокирует доступ скриптам к файловой системе, что гарантирует невозможность запуска вредоносного кода (исключение: sm.json может читать и записывать файлы в вашей файловой системы, но не запускать их).
## Сервер
Серверная часть имитирует игровой мир и взаимодействует со всеми клиентами, которые в данный момент играют, включая самого хоста. Серверная часть запущена только на компьютере игрока-хоста.
В классе скриптов `serverEventCallback` подразумевает, что код будет выполняться в серверном режиме и иметь доступ *только к серверным* функциям, а также *к клиенту и серверу*. Чтобы проверить, выполняется ли скрипт в серверном режиме во время выполнения, вы можете использовать функцию `sm.isServerMode()`.
## Клиент
Клиент – это часть Scrap Mechanic, которую игрок видит и с которой взаимодействует - например, графика, аудио, ввод. Клиент запущен на компьютере каждого игрока, включая хоста.
В классе скриптов `clientEventCallback` подразумевает, что обратный вызов будет выполняться в клиентском режиме, ограничивая Lua возможностью вызывать только *клиентские и клиентско-серверные* функции.